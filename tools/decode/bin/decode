#!/usr/bin/python3
import os
import sys
sys.path.insert(0, os.environ.get("VIRTUAL_ENV") + "/tools/decode")

from types import CodeType
from rich.syntax import Syntax
from multiprocessing import Process
from rich.console import Console
from utils.pysource import FakeFunction, DecompilePyc, DecompileMarshal, check
from algorithms.pyfile import open_python_file, get_file_type

console = Console()


def show_code(source: str, temp):
    if not temp:
        p = Process(target=show_code, args=(source, 1))
        p.start()
        p.join(5)
        if p.is_alive():
            p.kill()
            console.print("# [yellow]can't show the code because the file is too big![/yellow]")
    else:
        syntax = Syntax(source, "python", line_numbers=True)
        console.print(syntax)


def show_info(file_type: str, layers: int):
    print(f"# file-type: {file_type}")
    print(f"# layers: {layers}")
    if input("# stop? [y/enter]: ").strip() == "y":
        if input("# delete old file? [y/n]: ").strip() == "y":
            os.remove(sys.argv[1])
        exit(0)


def no_support():
    console.print("# No support currently! please wait for the new updates.")
    exit(0)


def save_file(source, write_type="w"):
    os.system("clear")
    with open(sys.argv[2], write_type) as out:
        out.write(source)
    if write_type == "wb":
        console.print("# [green]Decoded as pyc. Can't show bytes.[/green]")
    else:
        show_code(source, 0)


def decode_handler(filename, layers):
    source = open_python_file(filename)
    file_type = get_file_type(filename)
    check(filename)
    if file_type == "zip":
       pass
    elif type(source) == str:
        source: Union[str, None, CodeType] = FakeFunction(source, filename).get_source()
    elif type(source) == bytes:
        source: str = DecompilePyc(filename).get_source()
    else:
        no_support()

    if type(source) == str:
        layers += 1
        save_file(source)
        show_info(file_type, layers)
        main(layers=layers)
    elif type(source) == CodeType:
        source: bytes = DecompileMarshal(source).get_source()
        layers += 1
        save_file(source, write_type="wb")
        show_info(file_type, layers)
        main(layers=layers)
    else:
        no_support()


def main(layers=0):
    if len(sys.argv) < 3:
        os.system("readme decode")
        exit(0)
    
    filename = sys.argv[2 if layers else 1]
    if not os.path.isfile(filename):
        exit(f"# File '{filename}' not found!")

    decode_handler(filename, layers)


if __name__ == "__main__":
    main()
